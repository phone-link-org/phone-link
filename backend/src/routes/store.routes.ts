import { AuthenticatedRequest, hasRole, isAuthenticated } from "../middlewares/auth.middleware";
import {
  AddonFormData,
  StoreOfferModel,
  StoreOfferPriceFormData,
  OfferDto,
  PhoneDeviceDto,
  ReqPlanDto,
  PendingStoreDto,
  StoreRegisterFormData,
  StoreStaffData,
} from "shared/types";
import { PhoneDevice } from "../typeorm/phoneDevices.entity";
import { Offer } from "../typeorm/offers.entity";
import { Addon } from "../typeorm/addons.entity";
import { Store } from "../typeorm/stores.entity";
import { ReqPlan } from "../typeorm/reqPlans.entity";
import { User } from "../typeorm/users.entity";
import { Seller } from "../typeorm/sellers.entity";
import { UserFavorites } from "../typeorm/userFavorites.entity";
import { AppDataSource } from "../db";
import { Router } from "express";
import { ROLES } from "../../../shared/constants";

const router = Router();

router.get("/stores", async (req, res) => {
  try {
    const storeRepo = AppDataSource.getRepository(Store);
    const stores = await storeRepo.find({
      where: {
        approvalStatus: "APPROVED",
      },
    });
    res.status(200).json({
      success: true,
      data: stores,
    });
  } catch (e) {
    console.error("Error during fetching stores", e);
    res.status(500).json({
      success: false,
      message: "Îß§Ïû• Î™©Î°ùÏùÑ Î∂àÎü¨Ïò§Îäî Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.",
      error: "Internal Server Error",
    });
  }
});

// Îß§Ïû•Î™Ö Ï§ëÎ≥µ ÌôïÏù∏ ÏóîÎìúÌè¨Ïù∏Ìä∏
router.get("/check-name", isAuthenticated, hasRole([ROLES.SELLER, ROLES.ADMIN]), async (req, res) => {
  try {
    const { inputStoreName } = req.query;

    if (!inputStoreName || typeof inputStoreName !== "string") {
      return res.status(400).json({
        success: false,
        message: "Îß§Ïû•Î™ÖÏùÑ ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî.",
        error: "Bad Request",
      });
    }

    const storeRepo = AppDataSource.getRepository(Store);
    const transformedName = inputStoreName.trim().toLowerCase().replace(/\s+/g, "");

    // ÎåÄÏÜåÎ¨∏Ïûê Íµ¨Î∂Ñ ÏóÜÏù¥ ÎπÑÍµêÌïòÍ∏∞ ÏúÑÌï¥ Î™®Îì† Îß§Ïû•ÏùÑ Í∞ÄÏ†∏ÏôÄÏÑú ÎπÑÍµê
    const allStores = await storeRepo.find();
    const existingStore = allStores.find(
      (store) => store.name.trim().toLowerCase().replace(/\s+/g, "") === transformedName,
    );

    if (existingStore) {
      return res.status(200).json({
        success: true,
        data: {
          isDuplicate: true,
          message: "Ïù¥ÎØ∏ Ï°¥Ïû¨ÌïòÎäî Îß§Ïû•Î™ÖÏûÖÎãàÎã§.",
        },
      });
    } else {
      return res.status(200).json({
        success: true,
        data: {
          isDuplicate: false,
          message: "ÏÇ¨Ïö© Í∞ÄÎä•Ìïú Îß§Ïû•Î™ÖÏûÖÎãàÎã§.",
        },
      });
    }
  } catch (e) {
    console.error("Error during checking store name", e);
    res.status(500).json({
      success: false,
      message: "Îß§Ïû•Î™Ö ÌôïÏù∏ Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.",
      error: "Internal Server Error",
    });
  }
});

// Îß§Ïû• Îì±Î°ù ÏöîÏ≤≠ ÏóîÎìúÌè¨Ïù∏Ìä∏
router.post("/register", isAuthenticated, hasRole([ROLES.SELLER, ROLES.ADMIN]), async (req, res) => {
  try {
    const {
      name,
      regionCode,
      address,
      addressDetail,
      contact,
      thumbnailUrl,
      link_1,
      link_2,
      ownerName,
      description,
      approvalStatus,
      createdBy,
    } = req.body;

    // ÌïÑÏàò ÌïÑÎìú Í≤ÄÏ¶ù
    if (!name || !address || !contact || !regionCode) {
      return res.status(400).json({
        success: false,
        message: "ÌïÑÏàò Ï†ïÎ≥¥(Îß§Ïû•Î™Ö, Ï£ºÏÜå, Ïó∞ÎùΩÏ≤ò)Í∞Ä ÎàÑÎùΩÎêòÏóàÏäµÎãàÎã§.",
        error: "Bad Request",
      });
    }

    // Îß§Ïû•Î™Ö Ï§ëÎ≥µ ÌôïÏù∏
    const storeRepo = AppDataSource.getRepository(Store);
    const transformedName = name.trim().toLowerCase().replace(/\s+/g, "");
    const allStores = await storeRepo.find();
    const existingStore = allStores.find(
      (store) => store.name.trim().toLowerCase().replace(/\s+/g, "") === transformedName,
    );

    if (existingStore) {
      return res.status(409).json({
        success: false,
        message: "Ïù¥ÎØ∏ Ï°¥Ïû¨ÌïòÎäî Îß§Ïû•Î™ÖÏûÖÎãàÎã§.",
        error: "Conflict",
      });
    }

    // ÏÉà Îß§Ïû• ÏÉùÏÑ±
    const newStore = storeRepo.create({
      name: name,
      regionCode: regionCode,
      address: address,
      addressDetail: addressDetail || null,
      contact: contact.trim(),
      thumbnailUrl: thumbnailUrl || null,
      link_1: link_1?.trim() || null,
      link_2: link_2?.trim() || null,
      ownerName: ownerName?.trim() || null,
      description: description || null,
      approvalStatus: approvalStatus || "PENDING",
      createdBy: createdBy,
    });

    await storeRepo.save(newStore);

    res.status(201).json({
      success: true,
      message: "Îß§Ïû• Îì±Î°ù ÏöîÏ≤≠Ïù¥ ÏÑ±Í≥µÏ†ÅÏúºÎ°ú Ï†úÏ∂úÎêòÏóàÏäµÎãàÎã§.",
      data: {
        id: newStore.id,
        name: newStore.name,
        approvalStatus: newStore.approvalStatus,
      },
    });
  } catch (error) {
    console.error("Error during store registration", error);
    res.status(500).json({
      success: false,
      message: "Îß§Ïû• Îì±Î°ù ÏöîÏ≤≠ Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.",
      error: "Internal Server Error",
    });
  }
});

// ÏäπÏù∏ ÎåÄÍ∏∞ ÏÉÅÌÉúÏù∏ Îß§Ïû• Îç∞Ïù¥ÌÑ∞ Ï°∞Ìöå ÏóîÎìúÌè¨Ïù∏Ìä∏
router.get("/pending", isAuthenticated, hasRole([ROLES.ADMIN]), async (req, res) => {
  try {
    const storeRepo = AppDataSource.getRepository(Store);

    // ÏäπÏù∏ ÎåÄÍ∏∞ ÏÉÅÌÉúÏù∏ Îß§Ïû• Îç∞Ïù¥ÌÑ∞ Ï°∞Ìöå
    const pendingStores = await storeRepo
      .createQueryBuilder("s")
      .leftJoin("regions", "r", "s.region_code = r.code")
      .leftJoin("users", "u", "s.created_by = u.id")
      .select([
        "s.id as id",
        "s.name as name",
        "s.contact as contact",
        "s.created_at as createdAt",
        "s.created_by as createdBy",
        "s.region_code as regionCode",
        "r.name as regionName",
        "u.email as userEmail",
      ])
      .where("s.approval_status = :status", { status: "PENDING" })
      .getRawMany<PendingStoreDto>();

    res.status(200).json({
      success: true,
      data: pendingStores,
    });
  } catch (error) {
    console.error("Error during fetching pending stores", error);
    res.status(500).json({
      success: false,
      message: "ÏäπÏù∏ ÎåÄÍ∏∞ Îß§Ïû• Î™©Î°ù Ï°∞Ìöå Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.",
      error: "Internal Server Error",
    });
  }
});

//ÌäπÏ†ï Îß§Ïû• ÏãúÏÑ∏Ìëú Ï°∞Ìöå
router.get("/:storeId/offers", async (req, res) => {
  try {
    const { storeId } = req.params;
    const offerRepo = AppDataSource.getRepository(Offer);

    const response = await offerRepo
      .createQueryBuilder("o")
      .select([
        "o.id as id",
        "c.id as carrierId",
        "c.name as carrierName",
        "o.offer_type as offerType",
        "pm.id as modelId",
        "pm.name_ko as modelName",
        "ps.id as storageId",
        "ps.storage as storage",
        "o.price as price",
        "pm2.id as manufacturerId",
      ])
      .innerJoin("o.carrier", "c")
      .innerJoin("o.device", "pd")
      .innerJoin("pd.model", "pm")
      .innerJoin("pd.storage", "ps")
      .innerJoin("pm.manufacturer", "pm2")
      .where("o.store_id = :storeId", { storeId: parseInt(storeId) })
      .orderBy("pm2.id", "ASC")
      .addOrderBy("pm.release_date", "ASC")
      .addOrderBy("LENGTH(pm.name_ko)", "ASC")
      .addOrderBy("pm.name_ko", "ASC")
      .addOrderBy("ps.storage", "ASC")
      .addOrderBy("c.id", "ASC")
      .addOrderBy("o.offer_type", "ASC")
      .getRawMany<StoreOfferPriceFormData>();

    // üîπ Í≥ÑÏ∏µ Íµ¨Ï°∞Î°ú Í∞ÄÍ≥µ
    const formattedData: StoreOfferModel[] = [];

    for (const row of response) {
      // Î™®Îç∏ Ï∞æÍ∏∞
      let model = formattedData.find((m) => m.modelId === row.modelId);
      if (!model) {
        model = {
          manufacturerId: row.manufacturerId,
          modelId: row.modelId,
          modelName: row.modelName,
          storages: [],
        };
        formattedData.push(model);
      }

      // Ïä§ÌÜ†Î¶¨ÏßÄ Ï∞æÍ∏∞
      let storage = model.storages.find((s) => s.storageId === row.storageId);
      if (!storage) {
        storage = {
          storageId: row.storageId,
          storage: row.storage,
          carriers: [],
        };
        model.storages.push(storage);
      }

      // ÌÜµÏã†ÏÇ¨ Ï∞æÍ∏∞
      let carrier = storage.carriers.find((c) => c.carrierId === row.carrierId);
      if (!carrier) {
        carrier = {
          carrierId: row.carrierId,
          carrierName: row.carrierName,
          offerTypes: [],
        };
        storage.carriers.push(carrier);
      }

      // Ï°∞Í±¥ Ï∂îÍ∞Ä
      carrier.offerTypes.push({
        offerType: row.offerType,
        price: row.price,
      });
    }

    res.status(200).json({
      success: true,
      data: formattedData,
    });
  } catch (error) {
    console.error("Error during fetching offers", error);
    res.status(500).json({
      success: false,
      message: "Í∞ÄÍ≤© Ï†ïÎ≥¥ Ï°∞Ìöå Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.",
      error: "Internal Server Error",
    });
  }
});

//ÌäπÏ†ï Îß§Ïû• ÏãúÏÑ∏Ìëú Ï†ÄÏû•
router.post(
  "/:storeId/offers",
  isAuthenticated,
  hasRole([ROLES.SELLER, ROLES.ADMIN]),
  async (req: AuthenticatedRequest, res) => {
    const { storeId } = req.params;
    const { offers } = req.body;
    const userId = req.user!.id; // ‚ùïÏù∏Ï¶ùÎêú ÏöîÏ≤≠Ïù¥ÎØÄÎ°ú user Í∞ùÏ≤¥Îäî Ìï≠ÏÉÅ Ï°¥Ïû¨

    const queryRunner = AppDataSource.createQueryRunner();
    await queryRunner.connect();
    await queryRunner.startTransaction();

    try {
      const offerRepo = queryRunner.manager.getRepository(Offer);
      const deviceRepo = queryRunner.manager.getRepository(PhoneDevice);

      // N+1 Î¨∏Ï†ú Ìï¥Í≤∞ÏùÑ ÏúÑÌï¥ ÌïÑÏöîÌïú Î™®Îì† device Ï†ïÎ≥¥Î•º ÎØ∏Î¶¨ Ï°∞Ìöå
      const deviceIdentifiers = offers.flatMap((model: StoreOfferModel) =>
        model.storages.map((storage) => ({
          modelId: model.modelId,
          storageId: storage.storageId,
        })),
      );
      const devices = await deviceRepo.find({ where: deviceIdentifiers });
      // Îπ†Î•∏ Ï°∞ÌöåÎ•º ÏúÑÌï¥ MapÏúºÎ°ú Î≥ÄÌôò: 'Î™®Îç∏ID-Ïä§ÌÜ†Î¶¨ÏßÄID'Î•º ÌÇ§Î°ú ÏÇ¨Ïö©
      const deviceMap = new Map(devices.map((d) => [`${d.modelId}-${d.storageId}`, d] as [string, PhoneDeviceDto]));

      // ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ÏóêÏÑú Î∞õÏùÄ Îç∞Ïù¥ÌÑ∞Î•º DBÏóê Ï†ÄÏû•Ìï† ÏµúÏ¢Ö ÌòïÌÉúÎ°ú Í∞ÄÍ≥µ
      const newOfferMap = new Map<string, OfferDto>();
      for (const model of offers) {
        for (const storage of model.storages) {
          for (const carrier of storage.carriers) {
            for (const offerType of carrier.offerTypes) {
              const device = deviceMap.get(`${model.modelId}-${storage.storageId}`);
              if (device) {
                // Ïú†ÎãàÌÅ¨Ìïú ÌÇ§Î•º ÏÉùÏÑ±ÌïòÏó¨ OfferÎ•º ÏãùÎ≥Ñ
                const offerKey = `${carrier.carrierId}-${device.id}-${offerType.offerType}`;
                const offerData: OfferDto = {
                  storeId: parseInt(storeId),
                  carrierId: carrier.carrierId,
                  deviceId: device.id,
                  offerType: offerType.offerType,
                  price: offerType.price,
                  updatedBy: userId,
                };
                newOfferMap.set(offerKey, offerData);
              }
            }
          }
        }
      }

      // DBÏóê Ï†ÄÏû•Îêú Í∏∞Ï°¥ Offer Îç∞Ïù¥ÌÑ∞Î•º Ï°∞Ìöå
      const existingOffers = await offerRepo.findBy({
        storeId: parseInt(storeId),
      });
      const existingOfferMap = new Map(
        existingOffers.map((o) => {
          const key = `${o.carrierId}-${o.deviceId}-${o.offerType}`;
          return [key, o];
        }),
      );

      // Ï∂îÍ∞Ä(Insert), ÏàòÏ†ï(Update), ÏÇ≠Ï†ú(Delete)Ìï† ÎåÄÏÉÅÏùÑ Î∂ÑÎ•ò
      const toInsert: OfferDto[] = [];
      const toUpdate: Offer[] = [];
      const toDelete: number[] = []; // id Î∞∞Ïó¥

      // ÏÉàÎ°úÏö¥ Îç∞Ïù¥ÌÑ∞Î•º Í∏∞Ï§ÄÏúºÎ°ú Insert/Update ÎåÄÏÉÅ Ï∞æÍ∏∞
      for (const [key, newOffer] of newOfferMap.entries()) {
        const existingOffer = existingOfferMap.get(key);

        if (existingOffer) {
          // Í∏∞Ï°¥Ïóê Îç∞Ïù¥ÌÑ∞Í∞Ä ÏûàÏúºÎ©¥
          // Í∞ÄÍ≤©Ïù¥ Îã§Î•º Í≤ΩÏö∞ÏóêÎßå ÏóÖÎç∞Ïù¥Ìä∏ Î™©Î°ùÏóê Ï∂îÍ∞Ä
          if (existingOffer.price !== newOffer.price) {
            toUpdate.push({ ...existingOffer, price: newOffer.price ?? null });
          }
          // ÎπÑÍµêÍ∞Ä ÎÅùÎÇú Ìï≠Î™©ÏùÄ Í∏∞Ï°¥ ÎßµÏóêÏÑú Ï†úÍ±∞
          existingOfferMap.delete(key);
        } else {
          // Í∏∞Ï°¥Ïóê Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏúºÎ©¥
          toInsert.push(newOffer); // Ï∂îÍ∞Ä Î™©Î°ùÏóê Ï∂îÍ∞Ä
        }
      }

      // Ïù¥Ï†ú existingOfferMapÏóê ÎÇ®ÏïÑÏûàÎäî Îç∞Ïù¥ÌÑ∞Îäî ÏÇ≠Ï†ú ÎåÄÏÉÅÏûÖÎãàÎã§.
      for (const offerToDelete of existingOfferMap.values()) {
        toDelete.push(offerToDelete.id);
      }

      // 5. Î∂ÑÎ•òÎêú Îç∞Ïù¥ÌÑ∞Î•º Î∞îÌÉïÏúºÎ°ú DB ÏûëÏóÖÏùÑ Ïã§ÌñâÌï©ÎãàÎã§.
      if (toDelete.length > 0) {
        await offerRepo.delete(toDelete);
      }
      if (toUpdate.length > 0) {
        await offerRepo.save(toUpdate);
      }
      if (toInsert.length > 0) {
        await offerRepo.insert(toInsert);
      }

      // 6. Î™®Îì† ÏûëÏóÖÏù¥ ÏÑ±Í≥µÌñàÏúºÎØÄÎ°ú Ìä∏ÎûúÏû≠ÏÖòÏùÑ Ïª§Î∞ãÌï©ÎãàÎã§.
      await queryRunner.commitTransaction();

      res.status(200).json({
        success: true,
        data: {
          inserted: toInsert.length,
          updated: toUpdate.length,
          deleted: toDelete.length,
        },
      });
    } catch (error) {
      // ÏóêÎü¨ Î∞úÏÉù Ïãú Î™®Îì† Î≥ÄÍ≤ΩÏÇ¨Ìï≠ÏùÑ Î°§Î∞±Ìï©ÎãàÎã§.
      await queryRunner.rollbackTransaction();
      console.error("Error during saving offers", error);
      res.status(500).json({
        success: false,
        message: "Í∞ÄÍ≤© Ï†ïÎ≥¥ Ï†ÄÏû• Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.",
        error: "Internal Server Error",
      });
    } finally {
      // ÏÇ¨Ïö©Ìïú QueryRunnerÎ•º Î∞òÎìúÏãú Ìï¥Ï†úÌï¥Ï§òÏïº Ìï©ÎãàÎã§.
      await queryRunner.release();
    }
  },
);

//ÌäπÏ†ï Îß§Ïû• Î∂ÄÍ∞ÄÏÑúÎπÑÏä§ Ï°∞Ìöå
router.get("/:storeId/addons", async (req, res) => {
  try {
    const { storeId } = req.params;
    const addonRepo = AppDataSource.getRepository(Addon);
    const result = await addonRepo.find({
      where: { storeId: parseInt(storeId) },
    });

    const parsedResult: AddonFormData[] = result.map((addon) => ({
      ...addon,
      carrierId: addon.carrierId,
      monthlyFee: addon.monthlyFee,
      durationMonths: addon.durationMonths,
      penaltyFee: addon.penaltyFee,
    }));

    res.status(200).json({
      success: true,
      data: parsedResult,
    });
  } catch (error) {
    console.error("Error during fetching addons", error);
    res.status(500).json({
      success: false,
      message: "Î∂ÄÍ∞ÄÏÑúÎπÑÏä§ Ï°∞Ìöå Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.",
      error: "Internal Server Error",
    });
  }
});

//ÌäπÏ†ï Îß§Ïû• Í∏∞Î≥∏ Ï†ïÎ≥¥ Ï°∞Ìöå
router.get("/:storeId/detail", async (req, res) => {
  try {
    const { storeId } = req.params;
    const storeRepo = AppDataSource.getRepository(Store);
    const store = await storeRepo.findOne({
      where: { id: parseInt(storeId) },
      select: [
        "name",
        "description",
        "regionCode",
        "address",
        "addressDetail",
        "contact",
        "thumbnailUrl",
        "link_1",
        "link_2",
        "ownerName",
        "approvalStatus",
        "createdBy",
      ],
    });

    if (!store) {
      res.status(404).json({
        success: false,
        message: "Îß§Ïû• ÏÉÅÏÑ∏Ï†ïÎ≥¥ Ï°∞Ìöå Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.",
        error: "Not Found",
      });
    } else {
      const responseData: StoreRegisterFormData = store;

      res.status(200).json({
        success: true,
        data: responseData,
      });
    }
  } catch (error) {
    console.error("Error during fetching store detail", error);
    res.status(500).json({
      success: false,
      message: "Îß§Ïû• ÏÉÅÏÑ∏Ï†ïÎ≥¥ Ï°∞Ìöå Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.",
      error: "Internal Server Error",
    });
  }
});

router.post(
  "/:storeId/edit-info",
  isAuthenticated,
  hasRole([ROLES.SELLER, ROLES.ADMIN]),
  async (req: AuthenticatedRequest, res) => {
    try {
      const { storeId } = req.params;
      const { editedStore } = req.body;

      // storeId Ïú†Ìö®ÏÑ± Í≤ÄÏÇ¨
      const storeIdNumber = parseInt(storeId);
      if (isNaN(storeIdNumber)) {
        return res.status(400).json({
          success: false,
          message: "Ïú†Ìö®ÌïòÏßÄ ÏïäÏùÄ Îß§Ïû• IDÏûÖÎãàÎã§.",
        });
      }

      const storeRepo = AppDataSource.getRepository(Store);

      // Îß§Ïû• Ï°¥Ïû¨ Ïó¨Î∂Ä ÌôïÏù∏
      const store = await storeRepo.findOne({ where: { id: storeIdNumber } });
      if (!store) {
        return res.status(404).json({
          success: false,
          message: "Îß§Ïû•ÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.",
        });
      }

      // Í∂åÌïú ÌôïÏù∏ (ADMINÏù¥ ÏïÑÎãå Í≤ΩÏö∞, Ìï¥Îãπ Îß§Ïû•Ïùò ÏßÅÏõêÏù∏ÏßÄ ÌôïÏù∏)
      if (req.user?.role !== ROLES.ADMIN) {
        const sellerRepo = AppDataSource.getRepository(Seller);
        const seller = await sellerRepo.findOne({
          where: {
            userId: req.user?.id,
            storeId: storeIdNumber,
            status: "ACTIVE",
          },
        });

        if (!seller) {
          return res.status(403).json({
            success: false,
            message: "Ìï¥Îãπ Îß§Ïû•Ïùò Ï†ïÎ≥¥Î•º ÏàòÏ†ïÌï† Í∂åÌïúÏù¥ ÏóÜÏäµÎãàÎã§.",
          });
        }
      }

      // Îß§Ïû• Í∏∞Î≥∏ Ï†ïÎ≥¥ ÏóÖÎç∞Ïù¥Ìä∏
      store.name = editedStore.name || store.name;
      store.description = editedStore.description !== undefined ? editedStore.description : store.description;
      store.regionCode = editedStore.regionCode || store.regionCode;
      store.address = editedStore.address || store.address;
      store.addressDetail = editedStore.addressDetail || store.addressDetail;
      store.contact = editedStore.contact || store.contact;
      store.link_1 = editedStore.link_1 !== undefined ? editedStore.link_1 : store.link_1;
      store.link_2 = editedStore.link_2 !== undefined ? editedStore.link_2 : store.link_2;
      store.thumbnailUrl = editedStore.thumbnailUrl !== undefined ? editedStore.thumbnailUrl : store.thumbnailUrl;
      if (req.user?.id) {
        store.updatedBy = req.user.id;
      }

      await storeRepo.save(store);

      res.status(200).json({
        success: true,
        message: "Îß§Ïû• Ï†ïÎ≥¥Í∞Ä ÏÑ±Í≥µÏ†ÅÏúºÎ°ú ÏàòÏ†ïÎêòÏóàÏäµÎãàÎã§.",
        data: store,
      });
    } catch (error) {
      console.error("Error during saving store info", error);
      res.status(500).json({
        success: false,
        message: "Îß§Ïû• Í∏∞Î≥∏ Ï†ïÎ≥¥ Ï†ÄÏû• Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.",
        error: "Internal Server Error",
      });
    }
  },
);

router.post("/:storeId/addon-save", isAuthenticated, hasRole([ROLES.SELLER, ROLES.ADMIN]), async (req, res) => {
  try {
    const { storeId } = req.params;
    const { addons } = req.body;

    // Ìä∏ÎûúÏû≠ÏÖòÏùÑ ÏÇ¨Ïö©ÌïòÏó¨ Îç∞Ïù¥ÌÑ∞ Î¨¥Í≤∞ÏÑ±ÏùÑ Î≥¥Ïû•
    const result = await AppDataSource.transaction(async (transactionalEntityManager) => {
      const storeIdNumber = parseInt(storeId);

      // Í∏∞Ï°¥ Îç∞Ïù¥ÌÑ∞ ÏÇ≠Ï†ú
      await transactionalEntityManager.delete(Addon, {
        storeId: storeIdNumber,
      });

      if (addons.length === 0) {
        return []; // Ï†ÄÏû•Ìï† Í≤ÉÏù¥ ÏóÜÏúºÎØÄÎ°ú Îπà Î∞∞Ïó¥ Î∞òÌôò
      }

      // ÏÉàÎ°úÏö¥ Îç∞Ïù¥ÌÑ∞Î•º Ï†ÄÏû•Ìï† Í∞ùÏ≤¥ Î∞∞Ïó¥ ÏÉùÏÑ±
      const newAddons = addons.map((addon: AddonFormData) => ({
        storeId: storeIdNumber,
        carrierId: addon.carrierId,
        name: addon.name,
        monthlyFee: addon.monthlyFee,
        durationMonths: addon.durationMonths,
        penaltyFee: addon.penaltyFee,
      }));

      // ÏÉàÎ°úÏö¥ Îç∞Ïù¥ÌÑ∞ Ï†ÄÏû•
      const savedAddons = await transactionalEntityManager.save(Addon, newAddons);

      return savedAddons;
    });

    res.status(200).json({
      success: true,
      message: "Î∂ÄÍ∞ÄÏÑúÎπÑÏä§Í∞Ä ÏÑ±Í≥µÏ†ÅÏúºÎ°ú Ï†ÄÏû•ÎêòÏóàÏäµÎãàÎã§.",
      data: result,
    });
  } catch (error) {
    console.error("Error during saving addons", error);
    res.status(500).json({
      success: false,
      message: "Î∂ÄÍ∞ÄÏÑúÎπÑÏä§ Ï†ÄÏû• Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.",
      error: "Internal Server Error",
    });
  }
});

router.get("/:storeId/req-plans", isAuthenticated, async (req, res) => {
  try {
    const { storeId } = req.params;
    const reqPlanRepo = AppDataSource.getRepository(ReqPlan);

    const plans = await reqPlanRepo.findBy({ storeId: parseInt(storeId) });

    res.status(200).json({
      success: true,
      data: plans,
    });
  } catch (error) {
    console.error("Error fetching req plans", error);
    res.status(500).json({
      success: false,
      message: "ÏöîÍ∏àÏ†ú Ï†ïÎ≥¥ Ï°∞Ìöå Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.",
      error: "Internal Server Error",
    });
  }
});

router.post("/:storeId/req-plans", isAuthenticated, hasRole(["SELLER"]), async (req, res) => {
  try {
    const storeIdString: string = req.params.storeId;
    const plans: ReqPlanDto[] = req.body;

    const result = await AppDataSource.transaction(async (transactionEntityManager) => {
      const storeId: number = parseInt(storeIdString);

      // 1. Í∏∞Ï°¥ Îç∞Ïù¥ÌÑ∞ ÏÇ≠Ï†ú
      await transactionEntityManager.delete(ReqPlan, { storeId: storeId });

      if (plans.length === 0) {
        return [];
      }

      // 2. ÏÉà Îç∞Ïù¥ÌÑ∞ Ï∂îÍ∞Ä
      const newReqPlans = plans.map((plan: ReqPlanDto) => ({
        storeId: storeId,
        name: plan.name,
        carrierId: plan.carrierId,
        monthlyFee: plan.monthlyFee || 0,
        duration: plan.duration || 0,
      }));
      const savedReqPlans = await transactionEntityManager.save(ReqPlan, newReqPlans);

      return savedReqPlans;
    });

    res.status(200).json({
      success: true,
      message: "ÏöîÍ∏àÏ†úÍ∞Ä ÏÑ±Í≥µÏ†ÅÏúºÎ°ú Ï†ÄÏû•ÎêòÏóàÏäµÎãàÎã§.",
      data: result,
    });
  } catch (error) {
    console.error("Error saving req plans", error);
    res.status(500).json({
      success: false,
      message: "ÏöîÍ∏àÏ†ú Ï†ÄÏû• Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.",
      error: "Internal Server Error",
    });
  }
});

// Ï¶êÍ≤®Ï∞æÍ∏∞ ÏÉÅÌÉú Ï°∞Ìöå ÏóîÎìúÌè¨Ïù∏Ìä∏
router.get("/favorite", isAuthenticated, async (req, res) => {
  try {
    const { userId, storeId } = req.query;

    if (!userId || !storeId) {
      return res.status(400).json({
        success: false,
        message: "ÏÇ¨Ïö©Ïûê IDÏôÄ Îß§Ïû• IDÍ∞Ä ÌïÑÏöîÌï©ÎãàÎã§.",
        error: "Bad Request",
      });
    }

    const favoriteRepo = AppDataSource.getRepository(UserFavorites);
    const favorite = await favoriteRepo.findOne({
      where: {
        userId: parseInt(userId as string),
        storeId: parseInt(storeId as string),
      },
    });

    const isFavorite = !!favorite;

    res.status(200).json({
      success: true,
      data: isFavorite,
    });
  } catch (error) {
    console.error("Error during fetching favorite status", error);
    res.status(500).json({
      success: false,
      message: "Ï¶êÍ≤®Ï∞æÍ∏∞ ÏÉÅÌÉú Ï°∞Ìöå Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.",
      error: "Internal Server Error",
    });
  }
});

// Ï¶êÍ≤®Ï∞æÍ∏∞ ÌÜ†Í∏Ä ÏóîÎìúÌè¨Ïù∏Ìä∏
router.post("/favorite", isAuthenticated, async (req, res) => {
  try {
    const { userId, storeId } = req.body;

    if (!userId || !storeId) {
      return res.status(400).json({
        success: false,
        message: "ÏÇ¨Ïö©Ïûê IDÏôÄ Îß§Ïû• IDÍ∞Ä ÌïÑÏöîÌï©ÎãàÎã§.",
        error: "Bad Request",
      });
    }

    const favoriteRepo = AppDataSource.getRepository(UserFavorites);

    // Í∏∞Ï°¥ Ï¶êÍ≤®Ï∞æÍ∏∞ ÌôïÏù∏
    const existingFavorite = await favoriteRepo.findOne({
      where: {
        userId: parseInt(userId),
        storeId: parseInt(storeId),
      },
    });

    let isFavorite: boolean;

    if (existingFavorite) {
      // Ï¶êÍ≤®Ï∞æÍ∏∞Í∞Ä ÏûàÏúºÎ©¥ ÏÇ≠Ï†ú
      await favoriteRepo.remove(existingFavorite);
      isFavorite = false;
    } else {
      // Ï¶êÍ≤®Ï∞æÍ∏∞Í∞Ä ÏóÜÏúºÎ©¥ Ï∂îÍ∞Ä
      const newFavorite = favoriteRepo.create({
        userId: parseInt(userId),
        storeId: parseInt(storeId),
      });
      await favoriteRepo.save(newFavorite);
      isFavorite = true;
    }

    res.status(200).json({
      success: true,
      data: isFavorite,
    });
  } catch (error) {
    console.error("Error during toggling favorite", error);
    res.status(500).json({
      success: false,
      message: "Ï¶êÍ≤®Ï∞æÍ∏∞ Ï≤òÎ¶¨ Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.",
      error: "Internal Server Error",
    });
  }
});

router.get("/:storeId/staffs", isAuthenticated, hasRole([ROLES.SELLER, ROLES.ADMIN]), async (req, res) => {
  try {
    const { storeId } = req.params;

    const staffs = await AppDataSource.createQueryBuilder()
      .select([
        "u.id as userId",
        "u.email as email",
        "u.name as name",
        "u.nickname as nickname",
        "u.profile_image_url as profileImageUrl",
        "u.phone_number as phoneNumber",
        "u.status as systemStatus",
        "s.status as storeStatus",
      ])
      .from(User, "u")
      .innerJoin("sellers", "s", "u.id = s.user_id")
      .where("s.store_id = :storeId", { storeId: parseInt(storeId) })
      .getRawMany<StoreStaffData>();

    res.status(200).json({
      success: true,
      data: staffs,
    });
  } catch (error) {
    console.error("Error during fetching staffs", error);
    res.status(500).json({
      success: false,
      message: "ÏßÅÏõê Ï°∞Ìöå Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.",
      error: "Internal Server Error",
    });
  }
});

router.post("/update-staff-status", isAuthenticated, hasRole([ROLES.SELLER, ROLES.ADMIN]), async (req, res) => {
  const queryRunner = AppDataSource.createQueryRunner();
  await queryRunner.connect();
  await queryRunner.startTransaction();

  try {
    const { storeId, userId, newStatus } = req.body;
    const sellerRepo = queryRunner.manager.getRepository(Seller);
    const userRepo = queryRunner.manager.getRepository(User);

    const seller = await sellerRepo.findOne({ where: { storeId: parseInt(storeId), userId: parseInt(userId) } });
    if (!seller) {
      await queryRunner.rollbackTransaction();
      return res.status(404).json({
        success: false,
        message: "ÏßÅÏõê Ï°∞Ìöå Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.",
      });
    }

    const oldStatus = seller.status;
    seller.status = newStatus as "ACTIVE" | "INACTIVE" | "PENDING" | "REJECTED";
    await sellerRepo.save(seller);

    // seller status Î≥ÄÍ≤Ω Ïãú users ÌÖåÏù¥Î∏îÏùò roleÎèÑ Î≥ÄÍ≤Ω
    const user = await userRepo.findOne({ where: { id: parseInt(userId) } });
    if (user) {
      // ACTIVE ‚Üí INACTIVE: ÌåêÎß§Ïûê Í∂åÌïú Ìï¥Ï†ú
      if (oldStatus === "ACTIVE" && newStatus === "INACTIVE") {
        user.role = ROLES.USER;
        await userRepo.save(user);
      }
      // PENDING ‚Üí REJECTED: ÌåêÎß§Ïûê ÏäπÏù∏ Í±∞Ï†à
      else if (oldStatus === "PENDING" && newStatus === "REJECTED") {
        user.role = ROLES.USER;
        await userRepo.save(user);
      }
      // Í≥ÑÏ†ï Ï†ïÎ≥¥ ÏàòÏ†ï Î™®Îã¨ÏóêÏÑú ÏäπÏù∏ Ï†Ñ(PENDING) ÏÉÅÌÉúÏóêÏÑú Îã§Ïãú 'ÏùºÎ∞ò ÏÇ¨Ïö©ÏûêÎ°ú' Î≥ÄÍ≤Ω
      else if (oldStatus === "PENDING" && newStatus === "INACTIVE") {
        user.role = ROLES.USER;
        await userRepo.save(user);
        await sellerRepo.remove(seller);
      }
    }

    await queryRunner.commitTransaction();

    res.status(200).json({
      success: true,
      message: "ÏßÅÏõê ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏ ÏôÑÎ£å",
    });
  } catch (error) {
    await queryRunner.rollbackTransaction();
    console.error("Error during updating staff status", error);
    res.status(500).json({
      success: false,
      message: "ÏßÅÏõê ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏ Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.",
      error: "Internal Server Error",
    });
  } finally {
    await queryRunner.release();
  }
});

// ÏÇ¨Ïö© Í∞ÄÎä•Ìïú Î™®Îç∏ Î™©Î°ù Ï°∞Ìöå (ÏïÑÏßÅ Îì±Î°ùÎêòÏßÄ ÏïäÏùÄ Î™®Îç∏Îì§)
router.get("/:storeId/available-models", isAuthenticated, hasRole([ROLES.SELLER, ROLES.ADMIN]), async (req, res) => {
  try {
    const { storeId } = req.params;

    const query = `
      SELECT
          pm.id,
          pm.name_ko,
          pm.manufacturer_id
      FROM
          phone_models pm
      JOIN (
          SELECT model_id, COUNT(*) AS total_storage_count
          FROM phone_devices
          GROUP BY model_id
      ) AS model_storage_totals ON pm.id = model_storage_totals.model_id
      LEFT JOIN (
          SELECT pd.model_id, COUNT(DISTINCT pd.storage_id) AS offered_storage_count
          FROM offers o
          JOIN phone_devices pd ON o.device_id = pd.id
          WHERE o.store_id = ?
          GROUP BY pd.model_id
      ) AS store_offer_counts ON pm.id = store_offer_counts.model_id
      WHERE
          model_storage_totals.total_storage_count > COALESCE(store_offer_counts.offered_storage_count, 0)
      ORDER BY
          pm.manufacturer_id,
          pm.release_date DESC,
          pm.name_ko;
    `;

    const result = await AppDataSource.query(query, [parseInt(storeId)]);

    // pm.idÏôÄ pm.manufacturer_idÎ•º numberÎ°ú ÌååÏã±
    const parsedResult = result.map((item: { id: string; name_ko: string; manufacturer_id: string }) => ({
      ...item,
      id: parseInt(item.id),
      manufacturer_id: parseInt(item.manufacturer_id),
    }));

    res.status(200).json({
      success: true,
      data: parsedResult,
    });
  } catch (error) {
    console.error("Error during fetching available models", error);
    res.status(500).json({
      success: false,
      message: "ÏÇ¨Ïö© Í∞ÄÎä•Ìïú Î™®Îç∏ Î™©Î°ùÏùÑ Î∂àÎü¨Ïò§Îäî Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.",
      error: "Internal Server Error",
    });
  }
});

// ÏÑ†ÌÉùÎêú Î™®Îç∏Ïùò ÏÇ¨Ïö© Í∞ÄÎä•Ìïú Ïö©Îüâ Î™©Î°ù Ï°∞Ìöå
router.get("/:storeId/available-storages", isAuthenticated, hasRole([ROLES.SELLER, ROLES.ADMIN]), async (req, res) => {
  try {
    const { storeId } = req.params;
    const { modelId } = req.query;

    if (!modelId) {
      return res.status(400).json({
        success: false,
        message: "Î™®Îç∏ IDÍ∞Ä ÌïÑÏöîÌï©ÎãàÎã§.",
      });
    }

    const query = `
      SELECT
          ps.id,
          ps.storage
      FROM
          phone_storages ps
      JOIN
          phone_devices pd ON ps.id = pd.storage_id
      WHERE
          pd.model_id = ?
          AND NOT EXISTS (
              SELECT 1
              FROM offers o
              WHERE
                  o.store_id = ?
                  AND o.device_id = pd.id
          )
      ORDER BY
          CASE
              WHEN ps.storage LIKE '%TB' THEN CAST(REPLACE(ps.storage, 'TB', '') AS UNSIGNED) * 1024
              WHEN ps.storage LIKE '%GB' THEN CAST(REPLACE(ps.storage, 'GB', '') AS UNSIGNED)
              ELSE 0
          END ASC;
    `;

    const result = await AppDataSource.query(query, [parseInt(modelId as string), parseInt(storeId)]);

    // ps.idÎ•º numberÎ°ú ÌååÏã±
    const parsedResult = result.map((item: { id: string; storage: string }) => ({
      ...item,
      id: parseInt(item.id),
    }));

    res.status(200).json({
      success: true,
      data: parsedResult,
    });
  } catch (error) {
    console.error("Error during fetching available storages", error);
    res.status(500).json({
      success: false,
      message: "ÏÇ¨Ïö© Í∞ÄÎä•Ìïú Ïö©Îüâ Î™©Î°ùÏùÑ Î∂àÎü¨Ïò§Îäî Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.",
      error: "Internal Server Error",
    });
  }
});

export default router;
